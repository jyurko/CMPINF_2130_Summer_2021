---
title: "CMPINF 2130 Summer 2021 - Extra examples"
subtitle: "Quick introduction to maps"
author: "Dr. Joseph P. Yurko"
date: "July 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview

This RMarkdown document introduces visualizing geospatial data with maps. This is not a comprehensive introduction but rather shows several useful starting points for visualizing data on a map. Please see [Chapter 4](https://plotly-r.com/maps.html) of the *Interactive web-based data visualization with R, plotly, and shiny* book (this book will be referred to as the plotly-r book for the remainder of the report) for a detailed overview of numerous map plotting packages within `R`.  

After introducing basic concepts and several packages, the report demonstrates visualizing Major League Baseball (MLB) player counts per US state and across countries.    

## Packages

As usual we will work with the `tidyverse` in this report and create maps using `ggplot2`. However, there are numerous plotting packages that also support maps. Some are highly specialized to visualizing geospatial data and offer greater control and flexibility with maps that `ggplot2`. Please see Chapter 4 of the plotly-r book for a comprehensive live of the dedicated mapping packages.  

The code chunk below loads the `tidyverse`. Later sections of the report will load in other packages as necessary.  

```{r, load_tidyverse_pkg}
library(tidyverse)
```

We will not load in the `maps` package, but you must download and install the `maps` package in order to run the code in the next section.  

## Maps with ggplot2

We will begin by creating a map of the contiguous 48 states. The necessary information required to create the map can be brought in via the `map_data()` from the `dplyr` package (which is loaded with `tidyverse`). The `map_data()` function converts geospatial map data from the `maps` package into data frame that can be manipulated for plotting via `ggplot2`. You must have the `maps` package downloaded and installed, but you do not need to load the `maps` package to get the data.  

The `map_data()` function requires the name of a map. The contiguous 48 states can be extracted with the `'state'` map.  

```{r, get_us_state_info}
us48 <- map_data('state')

us48 %>% class()
```

As we can see above, `us48` is a `data.frame`. Let's check the structure with `glimpse()`.  

```{r, check_us48_str}
us48 %>% glimpse()
```

The `long` and `lat` variables in `us48` are longitude and latitude coordinates. These coordinates are associated with positions around the borders of each state. The state name corresponds to the `region` column. Let's check the data associated with Pennsylvania.  

```{r, check_us48_pa}
us48 %>% 
  filter(region == "pennsylvania") %>% 
  tibble::as_tibble()
```

There are 172 rows associated with PA! Each row corresponds to a combination of `long` and `lat`. The `count()` function is used to count the number of `long` and `lat` combinations for PA in the code chunk below.  

```{r, check_us48_pa_counts}
us48 %>% 
  filter(region == "pennsylvania") %>% 
  tibble::as_tibble() %>% 
  count(long, lat) %>% 
  arrange(desc(n))
```

As we can above, there is one `long` and `lat` combination that occurs twice. This is the position where the border of the state "returns" back to the start. The easiest way to understand this is to create a scatter plot. The `long` variable is mapped to the `x` aesthetic and the `lat` variable is mapped to the `y` aesthetic in the code chunk below. Notice that the data are filtered to focus just on PA. Does the outline of the points look like PA?  

```{r, viz_pa_scatter_plot}
us48 %>% 
  filter(region == "pennsylvania") %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_point() +
  theme_bw()
```

Although the above scatter plot gives us the rough idea of the state, it is probably not what you had in map when you thought of a map. We would prefer a continuous line around the state border. We may also want a color to fill the region within the border. In `ggplot2`, we can think of a state as a *polygon*. The polygon itself is a collection or *group* of points. The points define the border or boundary of the polygon. Each point is defined by an `x` and `y` aesthetic. The polygon is created with the `geom_polygon()` function. Let's include the polygon layer and the scatter plot point layer we used previously to visualize PA. The polygon fill (color applied within a region or area) is set to `grey` and the marker size of `geom_point()` has been increased to 3. As we can see below, the points are located along the boundary of the polygon!  

```{r, viz_pa_scatter_polygon}
us48 %>% 
  filter(region == "pennsylvania") %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(fill = 'grey') +
  geom_point(size = 3) +
  theme_bw()
```

If we use the `geom_count()` geom instead of `geom_point()`, we can identify the starting point of the boundary around PA. That point has 2 observations, while all other points have just 1 observation. As we see below, the start and end of the boundary occurs at the top vertex along Lake Erie.  

```{r, viz_pa_count_polygon}
us48 %>% 
  filter(region == "pennsylvania") %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(fill = 'grey') +
  geom_count() +
  theme_bw()
```


Let's now remove the points and focus just on the polygon. The polygon fill is set to grey and the line (boundary) color is set to black. We now have a visualization that looks like a map of the commonwealth of PA!  

```{r, viz_pa_polygon}
us48 %>% 
  filter(region == "pennsylvania") %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(fill = 'grey', color = 'black') +
  theme_bw()
```

We can include other states in our visualization. For example, we can include Ohio and New Jersey with PA. However, the map does not look right! As we can see below, the filled in grey regions look odd. A strange triangle like shape is formed, which does not include any fill color.  

```{r, viz_pa_oh_nj_polygon}
us48 %>% 
  filter(region %in% c("pennsylvania", "ohio", "new jersey")) %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(fill = 'grey', color = 'black') +
  theme_bw()
```

The odd behavior is caused because `ggplot2` wants each polygon to be defined as a collection or *group* of points. The code used in the previous code chunk, does not provide any such grouping information. We did not map a variable in the data set to the `group` aesthetic. `ggplot2` thinks all points are point of one group and then tries to fill in the polygon accordingly. If you look closely, you can see the odd behavior is associated with the location of the start and end of the PA border. The "double counting" of the location makes sense only if those points are associated with one group, the PA group. The two other states included in the map have corresponding start and end points. The triangle-like shape has vertices located at the boundary start-and-end points for Ohio and New Jersey.  

To overcome this issue we need to specify the grouping structure. We must map a variable to the `group` aesthetic of `geom_polygon()`. The grouping variable of interest within the `us48` data set is the `group` column. The exact grouping variable in an arbitrary polygon will be problem dependent. Please see the [geom_polygon() documentation](https://ggplot2.tidyverse.org/reference/geom_polygon.html) to learn more about it, if you are interested.  

The correct grouping structure is applied in the code chunk below. Our map now correctly fills in the color of each state within the state borders!  

```{r, viz_pa_oh_nj_polygon_2}
us48 %>% 
  filter(region %in% c("pennsylvania", "ohio", "new jersey")) %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(fill = 'grey', color = 'black',
               mapping = aes(group = group)) +
  theme_bw()
```

Our above map though does not "look right". The aspect ratio is incorrect for a map. We need to use a coordinate system that is more appropriate for a map, rather than the default cartesian coordinate system that we typically work with. As shown below, the `coord_quickmap()` function will modify the coordinates to look like that of a map.  

```{r, viz_pa_oh_nj_polygon_3}
us48 %>% 
  filter(region %in% c("pennsylvania", "ohio", "new jersey")) %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(fill = 'grey', color = 'black',
               mapping = aes(group = group)) +
  coord_quickmap() +
  theme_bw()
```

We may also want to remove the axis and grid lines when visualizing maps. The `theme_void()` function is a quick way to do this.  

```{r, viz_pa_oh_nj_polygon_4}
us48 %>% 
  filter(region %in% c("pennsylvania", "ohio", "new jersey")) %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(fill = 'grey', color = 'black',
               mapping = aes(group = group)) +
  coord_quickmap() +
  theme_void()
```

Or we can use a dedicated theme for maps, with `ggthemes::theme_map()`.  

```{r, viz_pa_oh_nj_polygon_5}
us48 %>% 
  filter(region %in% c("pennsylvania", "ohio", "new jersey")) %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(fill = 'grey', color = 'black',
               mapping = aes(group = group)) +
  coord_quickmap() +
  ggthemes::theme_map()
```

Because we are working within `ggplot2` we can map aesthetics to other variables, just as we have done with other types of plots. For example, let's fill the polygons based on the state name. The code chunk below therefore also maps the `region` variable to the `fill` aesthetic of `geom_polygon()`.  

```{r, viz_pa_oh_nj_polygon_6}
us48 %>% 
  filter(region %in% c("pennsylvania", "ohio", "new jersey")) %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(color = 'black',
               mapping = aes(group = group,
                             fill = region)) +
  coord_quickmap() +
  ggthemes::scale_fill_colorblind() +
  theme_void() +
  theme(legend.position = "top")
```

We now have everything we need to create a map of the contiguous 48 states! The `x` and `y` aesthetics are mapped to the `long` and `lat` variables and the `group` aesthetic within `geom_polygon()` is mapped to the `region` variable. We also need an appropriate coordinate system for the map, with `coord_quickmap()`. The map is created in the code chunk below.  

```{r, viz_us48_polygon_map}
us48 %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(fill = 'grey', color = 'black',
               mapping = aes(group = group)) +
  coord_quickmap() +
  theme_void()
```

The important take aways from this example are:  
* We need points to describe the boundaries of regions of interest  
* Those points must be associated with a region via a grouping variable  

### US counties

The previous example worked with the boundaries of the US states. There are however many applications which require more fine grain spatial grouping structure. For example, we may want to work with individual counties and not just the states. The data must consist of points which define county boundaries. We can use the `map_data()` function to get the US county map data.  

```{r, get_us_county_map}
us_counties <- map_data("county")

us_counties %>% glimpse()
```

Let's first create the map associated with PA, similar to how we started with the US state map. The `x` and `y` aesthetics are mapped to the `long` and `lat` variables, respectively. Just as in the previous example, the `geom_polygon()` `group` aesthetic is mapped to the `group` variable. Can you identify Allegheny county in the map below? That's the county Pittsburgh is located within.  

```{r, viz_pa_county_polygon_1}
us_counties %>% 
  filter(region == "pennsylvania") %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(mapping = aes(group = group),
               fill = 'grey', color = 'black') +
  coord_quickmap() +
  theme_void()
```

Let's now look at the map of the counties in Ohio, New Jersey, and PA. The polygon `fill` aesthetic is mapped to the `region` variable. The polygon transparency is changed so that the county lines are more prevelant.  

```{r, viz_pa_nj_oh_counties_polygon}
us_counties %>% 
  filter(region %in% c("pennsylvania", "ohio", "new jersey")) %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(mapping = aes(group = group,
                             fill = region),
               color = 'black', alpha = 0.5) +
  coord_quickmap() +
  ggthemes::scale_fill_colorblind() +
  theme_void() +
  theme(legend.position = "top")
```

Visualizing the map of all counties in the contiguous 48 states is then a simple extension of the previous maps. The polygon fill is set to grey in the code chunk below.  

```{r, viz_us_counties_polygon}
us_counties %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(mapping = aes(group = group),
               fill = 'grey', color = 'black') +
  coord_quickmap() +
  theme_void()
```

We can combine the county level and state level data to denote the state boundaries as well as the county boundaries. The code chunk below uses two separate `geom_polygon()` layers. The first `geom_polygon()` layer inherits the `us_counties` data from the parent `ggplot()` call. The polygon `fill` is set to `'white'` and the `color` is set to `'black'`. The second `geom_polygon()` layer has the `us48` object assigned to the `data` argument with the `fill` aethetic set to `NA` and the `color` aesthetic set to `'red'`. By setting `fill` to `NA`, the second polygon layer (the state layer) will not use a filled in color. We can therefore see the polygon color and fill from the lower layer (the county layer). The state layer sets the polygon line `size` to a larger value so the state boundaries are easier to see on top of the county boundaries.  

```{r, viz_us_counties_states_polygon}
us_counties %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(mapping = aes(group = group),
               fill = 'white', color = 'black') +
  geom_polygon(data = us48,
               fill = NA, color = 'red',
               mapping = aes(group = group),
               size = 1.) +
  coord_quickmap() +
  theme_void()
```

### World

We can also create a map of the world using this same approach. The `map_data()` function provides the world map as a `ggplot2` ready data frame.  

```{r, make_world_map}
map_data("world") %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(mapping = aes(group = group),
               fill = 'grey', color = 'black') +
  coord_quickmap() +
  theme_void()
```


## Simple features

The `geom_polygon()` function is a "generic" function. It has no concept of a county, state, or country. It is a "primitive" to allow filling in a region or area within a group or collection of points. Although we can create the maps and visualizations we would like using `geom_polygon()` there are many different speciality functions and data types to support more detailed visualizations of geospatial data.  

The `sf` package is designed specifically for working with geospatial data. The package name stands for "simple features" which is a formal standard for representing objects, especially spatial objects. The `sf` package builds on the success and functionality of the `sp` package, which is a more classic spatial data package in the `R` ecosystem. The [sf documentation](https://r-spatial.github.io/sf/index.html) is quite good. Multiple vignettes and numerous examples are provided to help you work with the simple feature format in more detail.  

The following sections require that you first download and install the `sf` package.  

### Basic example

Let's introduce simple features by working through the examples in the [Plotting Simple Features Vignette](https://r-spatial.github.io/sf/articles/sf5.html). The code chunk below loads in the `sf` package.  

```{r, load_sf_pkg}
library(sf)
```

The example works with data associated with North Carolina.  

```{r, read_sf_demo_nc_data}
demo(nc, ask = FALSE, echo = FALSE)
```

As we see below, the `nc` object is the `sf` data type, as well as a `data.frame`.  

```{r, check_nc_class}
nc %>% class()
```

Printing `nc` to the screen provides summary information and a glimpse of the data. Notice that the first line states there are 100 features and 14 fields. We see some useful summary information about the "bounding box" which surrounds the map, as well. A "feature" is a region of interest. As you see shortly, the `nc` data is associated with counties in North Carolina. There are 100 North Carolina counties and so the `nc` object contains information about those 100 counties. Thus in `tidyverse` terms a "feature" is a row or observation in a tibble! The fields are the variables or columns associated with the observation.  

```{r, show_nc_display}
nc
```

The "special" aspect of the Simple Features structure compared to a "regular" `data.frame` or `tibble` is that one of the fields (columns) is the geometric information associated with the feature. Following what we saw with plotting states and counties with `geom_polygon()`, the geometric information is the set of points which define the boundary of the feature.  

`sf` data type objects have their own default plotting functionality. We can plot just the "geometric" information by extracting the geomtric information with the `st_geometry()` function, and then calling the `plot()` function. The conventional "inside-out" function approach to this is shown below.  

```{r, viz_nc_demo_plot_1}
plot( st_geometry(nc) )
```

However, the "pipeline" approach via the forward pipe operator shows the actions performed to create the plot left-to-right.  

```{r, viz_nc_demo_plot_2}
nc %>% 
  st_geometry() %>% 
  plot()
```

By convention, the "inside-out" programming style is used when working with the default `sf` object plotting functionality. Following the vignette example, we can color each county by specifying the `col` argument to the default `plot()` function.  

```{r, viz_nc_demo_plot_3}
plot( st_geometry(nc), col=sf.colors(12, categorical = TRUE), border = 'black')
```

The feature centroid can be extracted using the `st_centroid()` function. This is a useful function to use if we would like to display information, such as text, at the center of a county. Two separate calls to the default `plot()` function are required to identify the centroid of the features, as shown below.  

```{r, viz_nc_demo_plot_4}
plot( st_geometry(nc), col=sf.colors(12, categorical = TRUE), border = 'black')
plot( st_geometry( st_centroid(nc) ), pch=3, col='red', add = TRUE)
```

However, the default behavior of the `sf` object plotting function is to create separate subplots for each field in object.  

```{r, viz_nc_demo_plot_5}
plot( nc )
```

By default, only 9 subplots are created. The `max.plot` argument is used to change the number of subplots created. Since there are 14 fields in `nc`, the `max.plot` is increased to 14 in the code chunk below.  

```{r, viz_nc_demo_plot_6}
plot( nc, max.plot = 14 )
```

We can plot a single field by selecting the field name using `[ ]` notation. For example, the area for each county is plotted below.  

```{r, viz_nc_demo_plot_7}
plot(nc['AREA'])
```

We can include the latitude and longitude coordinate axis is we would like.  

```{r, viz_nc_demo_plot_8}
plot(nc['AREA'], axes = TRUE)
```

Please see the [sf plotting vignette](https://r-spatial.github.io/sf/articles/sf5.html#color-key-place-and-size) to learn more about controlling color scales, legends, and how the projections are made within the `sf` package.  

### Choropleth

It is important to note that when we make a map and fill the features (counties in our current example) based on a field associated with the features we are creating a **choropleth**. For the example, the previous map visualized the county area in degree units. The `nc` object however contains other fields (columns) that we could be interested in visualizing. The `BIR74` field is the number of births in the 1974-1978 time period. Let's use the default plotting method for the `nc` object, selecting `BIR74`. The visualization below is therefore a choropleth showing the number of births in each county. 

```{r, viz_nc_demo_plot_9}
plot(nc['BIR74'])
```

As we saw previously, the default plot method for `sf` objects uses subplots to show a map for each field. This means the default plot method creates as many choropleths as there are fields!  

Please see the following references to learn more about the fields in the `nc` object. A general reference for the data source is [here](https://nowosad.github.io/spData/reference/nc.sids.html), and a reference providing an introduction to exploring and analyzing the spatial data is [here](https://r-spatial.github.io/spdep/articles/sids.html).  

### sf and ggplot2

As useful as the default `sf` object plotting functions are, I prefer working with `ggplot2`. Each `sf` "feature" is analogous to a polygon-group that we visualized in our first example which worked with with `geom_polygon()` directly. However, the `sf` object is not in a format which supports `geom_polygon()`. The `sf` object is an advanced data type where the rows consist of **multi-valued** information within the `geom` column. A "tidy" data set more appropriate for `geom_polygon()` requires each boundary point to have a row. As we saw previously, a boundary point is a single point on the boundary of a region (a *feature* in `sf` terminology). The `sf` object can therefore be viewed as a more compact data type, focused on the regions of interest, rather than the *region boundaries*. The `sf` object in some ways can be viewed as a nested data frame, whereas a long-format is more appropriate for `geom_polygon()`.  

We can see the difference between the `sf` object with a "tidy" `ggplot2` ready data set by comparing the number of rows in `nc` to the number of rows associated with North Carolina in the `us_counties` data set. As we see below, `nc` has 100 rows, one for each county in North Carolina.  

```{r, check_nc_sf_rows}
nc %>% nrow()
```

However, the `us_counties` data set has over 3600 rows associated with North Carolina!  

```{r, check_us_counties_nc_rows}
us_counties %>% 
  filter(region == "north carolina") %>% 
  nrow()
```

Since the `sf` object is more compact, we need a geometric object specialized to the nested-like `sf` structure. The `geom_sf()` function exists to meet this goal. It works with an `sf` object as the `data` argument to the `ggplot()` call. We do not need to map variables to the `x` and `y` aesthetics, or the `group` aesthetic. The `geom` column in the `sf` object is used to create the polygons associated with each feature automatically.  

The code chunk below demostrates how to visualize the county map in North Carolina using the `nc` `sf` object and the `geom_sf()` function.  

```{r, viz_nc_demo_plot_10}
nc %>% 
  ggplot() +
  geom_sf() +
  theme_void()
```

Let's compare the above map to one created using `geom_polygon()` and the `us_counties` data set.  

```{r, viz_nc_from_us_counties}
us_counties %>% 
  filter(region == "north carolina") %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(mapping = aes(group = group),
               fill = 'grey', color = 'black') +
  coord_quickmap() +
  theme_void()
```

In general the two maps are visually quite similar. The data used to create the maps are different, which is why the boundary resolution are different between the two. However, the primary point is that if we have a "tidy" long-format data structure for the spatial data we can use `geom_polygon()` with the appropriate `x`, `y`, and `group` aesthetics. If we have a special spatial data type, such as `sf`, for our map data, we can use the more streamlined `geom_sf()` to visualize the map.  

Now that we know how to create `ggplot2` visualizations with `sf` objects, let's consider how to create a choropleth. We simply need to map the `fill` aesthetic to the desired field in the `sf` object. For example, the `AREA` choropleth is created below.  

```{r, viz_nc_demo_plot_10_2}
nc %>% 
  ggplot() +
  geom_sf(mapping = aes(fill = AREA)) +
  scale_fill_viridis_c(option = 'plasma') +
  theme_void() +
  theme(legend.position = "bottom")
```

We can force a color map more consistent with the default `sf` plotting options by using the `scale_color_gradientn()` function, as shown below.  

```{r, viz_nc_demo_plot_11}
nc %>% 
  ggplot() +
  geom_sf(mapping = aes(fill = AREA)) +
  scale_fill_gradientn(colours = sf.colors(12)) +
  theme_void() +
  theme(legend.position = "bottom")
```

The terrain color palette is popular when visualizing spatial data. We must again use the `scale_fill_gradientn()` function, but we should assign the `terrain.colors()` function to the `colours` argument. As the name states, the colors look like natural terrain colors.  

```{r, viz_nc_demo_plot_12}
nc %>% 
  ggplot() +
  geom_sf(mapping = aes(fill = AREA)) +
  scale_fill_gradientn(colours = terrain.colors(12)) +
  theme_void() +
  theme(legend.position = "bottom")
```

We can force fewer color levels by specifying the argument to `terrain.colors()` to be a smaller valued integer.  

```{r, viz_nc_demo_plot_13}
nc %>% 
  ggplot() +
  geom_sf(mapping = aes(fill = AREA)) +
  scale_fill_gradientn(colours = terrain.colors(4)) +
  theme_void() +
  theme(legend.position = "bottom")
```


Creating a choropleth for another field with `geom_sf()` requires mapping a different field to the `fill` aesthetic. The choropleth for `BIR74` is shown below.  

```{r, viz_nc_demo_plot_14}
nc %>% 
  ggplot() +
  geom_sf(mapping = aes(fill = BIR74)) +
  scale_fill_gradientn(colours = sf.colors(12)) +
  theme_void() +
  theme(legend.position = "bottom") +
  theme(legend.text = element_text(size = 6.5))
```

Creating subplots via facets with `ggplot2` requires reshaping the `sf` object. Unfortunately, the newest `tidyverse` reshaping function `pivot_longer()` does not work perfectly with `sf` objects. We must use the slightly older, `tidyr::gather()` function to reshape into a longer format. `tidyr::gather()` creates an object similar to `pivot_longer()`, but it requires that we specify what we "do not want to gather" into the reshaped column. The minus sign operator, `-`, is used to identify the columns to "not gather". The code chunk below demonstrates selecting the `geom` and column and both `BIR74` and `BIR79` columns. The two `BIR` columns are "gathered together" by specifying `-geom` in the `gather()` call.   

```{r, nc_check_gather_bir}
nc %>% 
  select(geom, starts_with("BIR")) %>% 
  tidyr::gather(key = "key", value = "value", -geom)
```

As we can see above, each feature is now associated with a `key`. We will facet the `geom_sf()` choropleth by the `key` column to create a separate facet for each `BIR` variable.  

```{r, viz_nc_demo_plot_15}
nc %>% 
  select(geom, starts_with("BIR")) %>% 
  tidyr::gather(key = "key", value = "value", -geom) %>% 
  ggplot() +
  geom_sf(mapping = aes(fill = value)) +
  facet_wrap(~key, ncol = 1) +
  scale_fill_gradientn(colours = sf.colors(12)) +
  theme_void() +
  theme(legend.position = "bottom") +
  theme(legend.text = element_text(size = 6.5))
```

### other sf examples

The Simple Features concept is quite flexible. It allows storing spatial data at more fine grain detail than just countries, states, and counties. For example, the `tidycensus` package demonstrates how to visualize US Census data and American Community Survey (ACS) data at the census tract level within a county. Please the [spatial data in tidycensus](https://walker-data.com/tidycensus/articles/spatial-data.html) for an introduction, and the [tidycensus documentation](https://walker-data.com/tidycensus/index.html) in general for an overview.  

## Other plotting packages

### plotly

The `plotly` package includes many different approaches for visualizing maps. The [Chapter 4](https://plotly-r.com/maps.html#maps-integrated) of the plotly-r book provides an excellent introduction to making maps with plotly and so those examples will not be repeated here.  

### tmap

The `tmap` package is another popular map package. In produces high quality production ready maps. Please see the [getting started vignette](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html) for an introduction the [tmap CRAN page](https://cran.r-project.org/web/packages/tmap/index.html) for a complete set of vignettes.  

We will show just a few examples in this report. Therefore, if you would like to run the code below you must first download and install the `tmap` package.  

Let's start by loading `tmap`.  

```{r, load_tmap_package}
library(tmap)
```

`tmap` visualizations can work with simple feature `sf` objects. The North Carolina county map can therefore be visualized with the `qtm()` function, as shown below.  

```{r, viz_tmap_nc_example}
qtm(nc)
```

`tmap` also support interactive plots, similar to `plotly`. An interactive choropleth of the `BIR74` field from the `nc` object is shown below. The first step is to make the `tmap_mode()` a `'view'` mode.  

```{r, make_interactive_tmap_session}
tmap_mode("view")
```

Then, the `tm_shape()` and `tm_fill()` functions can be added together in the style of adding graphical layers on top of each other. The interactive view is particularly neat because the default "grey" area background can be replaced with a street map or topographical map.  

```{r, viz_tmap_bir_nc}
tm_shape(nc) + tm_fill("BIR74", palette = sf.colors(12))
```

### cartograms

Choropleths can be altered so that the spatial sizes of the states or countries are distorted based another field. These types of maps are known as **cartograms**. You might have seen such visualizations with election results where the state sizes represent population instead of land area. [Section 4.2.2](https://plotly-r.com/maps.html#cartograms) in the plotly-r book shows how to create cartograms in `R` using the `cartogram` package.  

## Example application

The maps we have visualized so far have worked with specially crafted spatial data. We have focused on either visualizing the region boundaries, or the choropleths showed fields already linked with the simple features object. However, we may wish to visualize data spatially that are not linked to spatial information. We must therefore join the data of interest with appropriate spatial data objects in order to create the maps.  

We will use a baseball example to demonstrate how to do this. The data comes from the `Lahman` package, and so you must download and install `Lahman` in order to run the code for this example.  

### Lahman data

The `Lahman` package is loaded in the code chunk below.  

```{r, load_lahman_pkg}
library(Lahman)
```


The `Lahman` package includes multiple data sets associated with every player and every season of Major League Baseball (MLB). We will focus on the `Master` table which contains biographic information about every player that has ever played in the MLB. One row of `Master` corresponds to a player. A glimpse of the `Master` table is shown below.  

```{r, show_lahman_master_glimpse}
Master %>% glimpse()
```

The `birthCountry` column gives the name of the country the player was born in. The `birthState` gives the name of the state within the country. We will start out by focusing on players born in the USA. We can visualize the number of MLB players from each state with a bar chart.  

```{r, viz_mlb_player_counts_states}
Master %>% 
  filter(birthCountry == "USA") %>% 
  ggplot(mapping = aes(y = birthState)) +
  geom_bar() +
  facet_wrap(~birthCountry) +
  theme_bw()
```

There's nothing wrong with the above bar chart. It is quite useful. However, it might also be interesting to visualize the counts on a map as a choropleth. The map will communicate spatial information so that we may assess if: states close together produce similar numbers of professional MLB players.  

We can create the appropriate counts by using `count()` or with `group_by()` and `summarize()`. The code chunk below uses the `count()` function.  

```{r, show_player_state_counts_1}
Master %>% 
  filter(birthCountry == "USA") %>% 
  count(birthState) %>% 
  arrange(desc(n))
```

As the example output displayed above shows, the summarized count data consists of two columns: the state abbreviation and the count. We need to merge or **join** this information to spatial data in order to visualize the counts as a choropleth.  

### map with geom_polygon()

One approach is to work with the "tidy" long-format spatial data already suited for `ggplot2`. The `us48` data set has the spatial information for the 48 contiguous states, as we previously saw. It therefore does not include Alaska and Hawaii, but it will serve to demonstrate the process. Let's check the names of the columns in `us48`:  

```{r, check_us48_colnames}
us48 %>% names()
```

If we recall from earlier in this report, the `region` variable corresponds to the state name:  

```{r, show_us48_head}
us48 %>% head()
```

As we see above though, the `region` variable consists of the state name in lower case letters. We can confirm this using `count()`.  

```{r, check_us48_count_region}
us48 %>% count(region)
```

This means the spatial data, `us48`, and the player summaries do not share a common variable or *key* that we can use to join with. We must therefore create use a *link table* to enable joining the two together. This link table consists of a column with the state name and a column for the abbreviation. Base `R` includes two vectors, `state.name` and `state.abb`, that consist of these two pieces of information! The state names are shown below:  

```{r, show_state_name_vec}
state.name
```

We can force all characters to lower case using the `stringr::str_to_lower()` function. `stringr` is a package within the `tidyverse` and so you should have it already.  

```{r, show_state_name_vec_lower}
stringr::str_to_lower(state.name)
```

The state abbreviations are:  

```{r, show_state_abb_vec}
state.abb
```

The link table is created in the code chunk below.  

```{r, make_state_link_table}
state_link <- tibble::tibble(
  name = stringr::str_to_lower(state.name),
  abbrev = state.abb
)
```

We can now join the state name to the summarized state counts via a `left_join()` as shown below.  

```{r, show_state_link_join_master}
Master %>% 
  filter(birthCountry == "USA") %>% 
  count(birthState) %>% 
  left_join(state_link, by = c("birthState" = "abbrev"))
```

And finally we can join the state summarized counts to the `us48` data. The code chunk below uses `right_join()` to join to the larger `us48` data set. Notice that the data manipulation pipeline uses the link table as the intermediary between the two data sets of interest.  

```{r, show_state_join_to_spatial_master}
Master %>% 
  filter(birthCountry == "USA") %>% 
  count(birthState) %>% 
  left_join(state_link, by = c("birthState" = "abbrev")) %>% 
  select(name, num_players = n) %>% 
  right_join(us48,
             by = c("name" = "region")) %>% 
  glimpse()
```

We can now visualize the choropleth for the number of players from each state using `geom_polygon()`.  

```{r, viz_state_counts_polygon}
Master %>% 
  filter(birthCountry == "USA") %>% 
  count(birthState) %>% 
  left_join(state_link, by = c("birthState" = "abbrev")) %>% 
  select(name, num_players = n) %>% 
  right_join(us48,
             by = c("name" = "region")) %>% 
  ggplot(mapping = aes(x = long, y = lat)) +
  geom_polygon(mapping = aes(group = group,
                             fill = num_players),
               color = 'black') +
  coord_quickmap() +
  scale_fill_gradientn("Number of MLB players - all time", colours = sf.colors(12)) +
  theme_void() +
  theme(legend.position = "bottom") +
  theme(legend.text = element_text(size = 6.5))
```

### map with geom_sf()

Alternatively, if the spatial data are contained within an `sf` object, we can visualize the choropleth with `geom_sf()`. If we continue to use the contiguous 48 state map from the `maps` package, we will need to **convert** the data to an `sf` object. This is easy to do thanks to the `st_as_sf()` function. However, rather than using `us48` (which was created via the `map_data()` function), we will convert the spatial data directly from the `maps` package. The code chunk below uses the `::` notation to access the necessary function with the `maps` package. This way we do not have to load in the `maps` package. The result is assigned to the `usa_sf` object.  

```{r, make_sf_version_us48}
usa_sf <- st_as_sf( maps::map('state', fill=TRUE, plot=FALSE) )

usa_sf %>% class()
```

The `class()` function confirms that `usa_sf` is indeed an `sf` object. The code chunk below displays the `usa_sf` to the screen. Again we first see summary information about the number of features and fields, as well as the bounding box around the entire map.  

```{r, show_sf_usa_object}
usa_sf
```

We can double check the `sf` object field names with the `names()` function.  

```{r, check_sf_usa_names}
usa_sf %>% names()
```

Thus, the state names in `usa_sf` correspond to the `ID` column. We must therefore merge the player counts per state to `usa_sf` via the link table. Rather than performing all operations - data manipulation, both joins, and visualization - in a single pipeline, let's first assign the player summary counts to the `players_per_state` object.  

```{r, make_players_per_state_tibble}
players_per_state <- Master %>% 
  filter(birthCountry == "USA") %>% 
  count(birthState) %>% 
  left_join(state_link, by = c("birthState" = "abbrev")) %>% 
  select(name, num_players = n)
```

The `players_per_state` data are joined to the `usa_sf` `sf` object via a left-join. The result is pipped into `ggplot()` and the choropleth is created with the appropriate `fill` aesthetic with `geom_sf()` in the code chunk below.  

```{r, viz_player_counts_map_sf}
usa_sf %>% 
  left_join(players_per_state,
            by = c("ID" = "name")) %>% 
  ggplot() +
  geom_sf(mapping = aes(fill = num_players)) +
  scale_fill_gradientn("Number of MLB players - all time", colours = sf.colors(12)) +
  theme_void() +
  theme(legend.position = "bottom") +
  theme(legend.text = element_text(size = 6.5))
```

As we can see above, the visualizations are consistent! Whether we want to use a "tidy" data set and `geom_polygon()` or an `sf` object with `geom_sf()`, the key point of this example was to show how the data of interest can be **joined** to spatial information.  

### World data

As one last example, let's visualize the number of players born per country. This way we can practice working with a map of the world, rather than a single country. Although we have already loaded in world spatial data via the `map_data()` function, we will use the `rnaturalearth` package to demonstrate working with data from another source. `rnaturalearth` is an `R` package which allows accessing data from [Natural Earth](https://www.naturalearthdata.com/), a free vector and raster map data repository at various spatial resolutions. Please see the [rnaturalearth getting started vignette](https://cran.r-project.org/web/packages/rnaturalearth/vignettes/rnaturalearth.html) to learn more about `rnaturalearth`.  

To run the following examples, you must download and install the `rnaturalearth` package. The code chunk below loads in `rnaturalearth`.  

```{r, load_rnatearth_pkg}
library(rnaturalearth)
```

We can load in the spatial data associated with countries using the `ne_countries()` function. If we do not specify any arguments to `ne_countries()` we will get the spatial data for all countries the world. The code chunk below gets the spatial world data and assigns the result to the `world` object.  

```{r, get_ne_world_data}
world <- ne_countries()

world %>% class()
```

As we see in the output display above, `world` is an `sp` class object. To use the set of functions we have discussed in this report, we must convert from the `sp` class to the `sf` class. Again, we can use the `st_as_sf()` function to convert the data type.  

```{r, convert_ne_world_class}
world <- st_as_sf( world )

world %>% class()
```

With `world` as the `sf` data type, we can now use `geom_sf()` to visualize the countries.  

```{r, viz_sf_world_countries}
world %>% 
  ggplot() +
  geom_sf() +
  theme_void()
```

Now that we have the necessary spatial data, let's return our attention back to the `Lahman` data set. The `Master` table includes the player's birth country as the `birthCountry` column. The code chunk counts the number of players born in each country.  

```{r, count_lahman_birth_by_country}
Master %>% 
  count(birthCountry) %>% 
  arrange(desc(n))
```

The printed output shows us that the `Lahman` package uses a mix of nation abbreviations and names. For example Mexico and Japan are spelled out, but the Dominican Republic is abbreviated as D.R. There are several other countries with abbreviations (and even a few countries with typos) in the `Lahman` data set. Let's check naming convention for the `sf` converted `world` object. As shown below, there are 64 columns (fields) in the `world` object!  

```{r, check_world_sf_field_names}
world %>% names()
```

The country name is stored in the `name` field, as confirmed by looking at a print out of a few fields below.  

```{r, check_few_world_sf_field_values}
world %>% 
  select(name, continent, geometry)
```

We can check for a specific string pattern using the `stringr::str_detect()` function. This allows us to look for a portion of a country name to double check how the `world` `sf` object has the name written. For example, to find the United States we can "look for" or detect any country with `"United"` in the `name` column of `world`. As we see below, the USA is listed as `'United States'`.  

```{r, check_few_world_sf_field_values_2}
world %>% 
  select(name, continent, geometry) %>% 
  filter(stringr::str_detect(name, "United"))
```

Next, let's check how the Dominican Republic is spelled within the `world` `sf` object.  

```{r, check_few_word_sf_field_values_3}
world %>% 
  select(name, continent, geometry) %>% 
  filter(stringr::str_detect(name, "Rep"))
```

We again have a missmatch in the Lahman country naming styles and our spatial data object. We will use another link table to enable joining the data sets together. The link table created below is not comprehensive. It was put together to demonstrate how to do this, but additional work is required to check if all countries are correctly included in the link table.  

```{r, make_lahman_link_table}
lahman_link <- tibble::tibble(
  birthCountry = c("USA", "D.R.", "CAN", "P.R.", "Viet Nam", "South Korea"),
  name = c("United States", "Dominican Rep.", "Canada", "Puerto Rico", "Vietnam", "Korea")
)
```

Joining `lahman_link` to the `Master` table by `birthCountry` adds the `name` column to `Lahman`. However, some missing values are present!  

```{r, join_lahman_link_to_master_1}
Master %>% 
  left_join(lahman_link, by = "birthCountry") %>% 
  select(playerID, birthCountry, name) %>% 
  purrr::map_dbl(~sum(is.na(.)))
```

A missing in the `name` column represents we can use the `birthCountry` as is. An example set of rows is shown below when `name` is missing.  

```{r, check_lahman_link_to_master_1}
Master %>% 
  left_join(lahman_link, by = "birthCountry") %>% 
  select(playerID, birthCountry, name) %>% 
  filter(is.na(name)) %>% 
  tibble::as_tibble()
```

The `name` column is mutated and reassigned to the result of an `ifelse()` function. The `ifelse()` function is an in-line if-else. A conditional test is provided in the first argument, if that value is TRUE the second argument is returned. Otherwise, the third argument is returned. We can therefore remove many of the missing values for `name` by setting `name` equal to `birthCountry` if `name` is missing. As shown below, the remaining missing rows for `name` correspond to those associated with missing `birthCountry` values.  

```{r, check_lahman_join_master_2}
Master %>% 
  left_join(lahman_link, by = "birthCountry") %>% 
  mutate(name = ifelse(is.na(name), birthCountry, name)) %>% 
  select(playerID, birthCountry, name) %>% 
  filter(is.na(name)) %>% 
  tibble::as_tibble()
```

We can now count the number of players associated with each country. The code chunk below assigns the result to the `players_per_country` object.  

```{r, make_count_players_per_country}
players_per_country <- Master %>% 
  left_join(lahman_link, by = "birthCountry") %>% 
  mutate(name = ifelse(is.na(name), birthCountry, name)) %>% 
  count(name) %>% 
  arrange(desc(n))

players_per_country %>% glimpse()
```

The choropleth for the number of players born per country is created in the code chunk below. The `players_per_country` object is joined to `world` via a `left_join()` by the `name` column. Since `world` is an `sf` object, the map is created with `geom_sf()`.  

```{r, viz_world_count_sf_1}
world %>% 
  left_join(players_per_country, by = "name") %>% 
  ggplot() +
  geom_sf(mapping = aes(fill = n)) +
  scale_fill_gradientn("Number of players born per country - All time", colours = sf.colors(12)) +
  theme_void() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 6.5))
```

Since one country dominates the counts, let's convert the number of players into a categorical variable. The deciles for the number of players per country are shown below to help get a sense of useful bin break points.  

```{r, check_count_per_country_deciles}
players_per_country %>% 
  pull(n) %>% 
  quantile(seq(0, 1, by = 0.1))
```

The binned player counts variable is added to `players_per_country` using the `cut()` function.  

```{r, make_player_bins_per_country}
players_per_country <- players_per_country %>% 
  mutate(player_bins = cut(n,
                           breaks = c(0,
                                      1, 
                                      3,
                                      5,
                                      10,
                                      20,
                                      50,
                                      100,
                                      200,
                                      400,
                                      800,
                                      max(n)),
                           include.lowest = TRUE))
```


The choropleth with the binned color scale is shown in the code chunk below.  

```{r, viz_world_count_sf_2}
world %>% 
  left_join(players_per_country, by = "name") %>% 
  ggplot() +
  geom_sf(mapping = aes(fill = player_bins)) +
  scale_fill_viridis_d("Players per country - All time", option = 'plasma') +
  theme_void() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 6.5)) +
  guides(fill = guide_legend(nrow = 2))
```

Since no players were born in Antarctica, let's remove it from the map.  

```{r, viz_world_count_sf_3}
world %>% 
  left_join(players_per_country, by = "name") %>% 
  filter(continent != "Antarctica") %>% 
  ggplot() +
  geom_sf(mapping = aes(fill = player_bins)) +
  scale_fill_viridis_d("Players per country - All time", option = 'plasma') +
  theme_void() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 6.5)) +
  guides(fill = guide_legend(nrow = 2))
```

## Conclusion

This report demonstrated how to create maps using several plotting packages, but mostly focused on `ggplot2` and the `sf` package. Please consult the plotly-r book for more examples and other packages you could consider.  